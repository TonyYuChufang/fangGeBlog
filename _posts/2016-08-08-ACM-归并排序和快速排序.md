---
published: true
layout: default
title: 归并排序&&快速排序
category: 算法
---

<h2> {{page.title}} </h2>
	
---

### 摘要：

> 归并排序，是一种基于分治思想的排序算法，它在递归到对数组的l(left)到r(right**)的位置之间的数进行排序。

> 快速排序，也是一种基于分治思想的排序，在递归过程中，通过选择一个基准数，将数组的一段分成比基准数小的和

> 比基准数大的两个部分，然后递归分别对这两个部分排序。看起来似乎与归并排序有点相似。相较于归并排序，快速

> 排序却在实际应用中用的更多，我们也可以在不同语言中使用已经封装好的快速排序函数（方法）。





## 归并排序

> 归并排序，是一种基于分治思想的排序算法，它在递归到对数组的l(**left**)到r(**right**)的位置之间的数进行排序。

    1. 首先根据中间位置==mid=(l+r)/2==分成两半。
    2. 然后递归的分别对左半部分和右半部份进行归并排序。
    3. 最后对两个已排序好的部分进行合并。
    
#### 注意：

归并排序也是所有高效排序算法中，唯一稳定的一个算法。

---

## 快速排序

	>     快速排序，也是一种基于分治思想的排序，在递归过程中，通过选择一个基准数，
	> ++ 将数组的一段分成比基准数小的和比基准数大的两个部分，然后递归分别对这两个部分排序 ++。
	> 看起来似乎与归并排序有点相似。相较于归并排序，快速排序却在实际应用中用的更多，
	> 我们也可以在不同语言中使用已经封装好的快速排序函数（方法）。

#### C语言版：

* 首先导入头文件：

```
 #include <stdlib.h>
```

* 假设已有数组```int a[10]```,调用qsort的方法如下：

```
 qsort(a,10,sizeof(int),comp);
```

* comp需要自己自定义，从小到大排，如下：

```
  int comp(const void* a, const void* b){
     return *(int *)a-*(int *)b;
  }
```

---

### C++版本：

* 相比C语言，C++语言的实现则更为简单,C\++语言的排序函数为sort，需要引入头文件

```
 #include <algorithm>
```

* 假设已有数组 ```int a[10]``` ，调用sort方法如下：

```
 sort(a,a+10);
```

---

### 具体C++代码：

```
#include <cstdio>
#include <iostream>
using namespace std;

void quick_sort(int dat[], int l, int r) {
    // 首先变量赋初值，i表示左端的index，j表示右端的index，mid表示基准值，基准值不确定，所以先暂定为最右端。
    int i = l, j = r, mid = dat[r];
    do {
		while (dat[i] < mid) ++i;  //从左开始，与基准值比较，直到找到比基准值大的数
		while (dat[j] > mid) --j;  //从右开始，与基准值比较，直到找到比基准值小的数
		if (i <= j) {
			swap(dat[i], dat[j]);
			++i; --j;
		}//若未重叠，着交换两数位置。即完成右边的数比基准值大，左边的数比基准值小的条件。
	} while (i < j);//若i已比j大，说明按基准值分组完成。
	// 递归调用，若左边部分数组数目仍大于1，则继续排左边部分数组
	if (l < j) quick_sort(dat,l,j);
	// 递归调用，同理，排右边部分数组。 
	if (i < r) quick_sort(dat,i,r);
}

int main() {
	int dat[10] = {1, 4, 3, 2, 5, 3, 2, 5, 10, 9};
	quick_sort(dat, 0, 9);
	for (int i = 0; i < 10; ++i)
		printf("%d ", dat[i]);
    return 0;
}
```